# 二叉树的遍历  
根结点、左结点、右结点  

## 树的遍历  
  根结点的输出顺序  
  1. 先序遍历：根节点 -> 先序遍历左子树 -> 先序遍历右子树
  2. 中序遍历：中序遍历左子树 -> 根节点 -> 中序遍历右子树
  3. 后序遍历：后序遍历左子树 -> 后序遍历右子树 -> 根节点  

## 关于递归  

- 递归：无限调用自身这个函数，每次调用总会改动一个关键变量，直到这个关键变量达到边界的时候，不再调用  
  简单来说：就是函数不断调用函数本身，就叫递归  

- **误区**：递归是把一个大问题拆分成可以重复执行的小问题，给每一层做同样的事情，不用去想每一层递归调用完了之后下一层函数又做了什么！不用关注整个递归需要走多少遍，每一遍得出什么结果，所以只需要关注每一级递归解决的问题即可  

- 什么情况用递归？  
  通常情况下，能被递归解决的问题具有以下两个特点：  
  1. 一个问题可以分解成具有相同解决思路的子问题，子子问题，换句话说这些问题都能调用同一个函数
  经过层层分解的子问题最后一定是有一个不能再分解的固定值的（即终止条件）,如果没有的话,就无穷无尽地分解子问题了，没有出口，死循环必定无解。  
  2. 在求解递归问题之前，必须通过以上两个特点验证是否能用递归求解。
  通过判断后，我们就可以使用递归的解题模板。  

- 递归思考三连：  
  1. 找整个递归的终止条件：递归应该在什么时候结束？  
  2. 找返回值：应该给上一级什么返回值？  
  3. 本级递归应该做什么：在这一级递归中，应该完成什么任务？  

## 方式一：递归遍历  

- 思考三连：  
  1. 递归的终止条件：节点为空 `if (root === null) return null;`  
  2. 返回值：这里不需要，只需要进行遍历  
  3. 本级递归要做的事情：读取节点的值，每个子结点(左边，右边)变成新的根节点 `arr.push(root.val);`  
  (读取顺序由递归的位置决定)

- 具体实现：  
  以先序为例：  
  ```js
  var preorderTraversal = function (root) {
    // 1, 2, 4, 5, 3, 6, 7
    let arr = [];
    const preorder = root => {
        if (root === null) return null; // 退出条件
        arr.push(root.val);
        preorder(root.left);
        preorder(root.right);
    }
    preorder(root);
    return arr;
  }
  ```

## 方式二：非递归实现  
思路：使用栈的操作来实现  
  
- **先序遍历**  
  思路：(要保证一定先访问根节点和左边的结点)  
  读取根结点，放进结果数组(相当于输出)，入栈(保留结点的引用，方便右子树的遍历)  
  一直访问其左子树，放进结果数组，入栈，直到最左边的叶结点  
  当结点为空时，出栈一个结点，访问其右结点  
  对整棵树循环这个过程  

- **中序遍历**  
  思路：(保证先从左边开始，所以要先走到最左边的叶结点)  
  读取根结点，先入栈(保留结点的引用)，往左走，重复入栈和往左走的步骤一直到最左边的叶结点  
  从最左边的叶结点开始读取，出栈，放进结果数组，出栈一个结点(根结点)  
  为空的时候出栈，放进结果数组，访问右边节点  
  不为空就往左走  
  对整棵树循环这个过程  

- **后序遍历**  
  思路：(可以看做是逆先序遍历，根结点 -> 右子树 -> 左子树)  
  和先序遍历思想一致，但是和先序遍历相反，从最右边的叶结点开始  
  读取根节点，放进放进结果数组(相当于输出)，入栈(保留结点的引用，方便左子树的遍历)  
  一直访问其右子树，放进结果数组，入栈，直到最右边的叶结点  
  当结点为空，出栈一个结点，访问其左结点  
  对整棵树循环这个过程  
  最后返回的结果数组要逆置  